package main

import (
	"flag"
	"fmt"
	"go/parser"
	"io/fs"
	"os"
	"path"
	"strings"

	"github.com/curtisnewbie/miso/util"
	"github.com/curtisnewbie/miso/version"
	"github.com/dave/dst"
	"github.com/dave/dst/decorator"
	"github.com/dave/dst/dstutil"
)

const (
	MisoApiPrefix = "misoapi-"

	typeMisoInbound = "miso.Inbound"
	typeMisoRail    = "miso.Rail"
	typeGormDb      = "gorm.DB"
	typeCommonUser  = "common.User"

	importCommonUser = "github.com/curtisnewbie/miso/middleware/user-vault/common"
	importMiso       = "github.com/curtisnewbie/miso/miso"

	tagHttp      = "http"
	tagDesc      = "desc"
	tagScope     = "scope"
	tagRes       = "resource"
	tagQueryDoc  = "query-doc"
	tagHeaderDoc = "header-doc"
)

var (
	Debug = flag.Bool("debug", false, "Debug")
)

func main() {
	flag.Usage = func() {
		util.Printlnf("misoapi for miso@%v\n", version.Version)
		util.Printlnf("Usage of %s:", os.Args[0])
		flag.PrintDefaults()
		util.Printlnf("\nFor example:\n")
		util.Printlnf("  misoapi-http: GET /open/api/doc")
		util.Printlnf("  misoapi-desc: open api endpoint to retrieve documents")
		util.Printlnf("  misoapi-query-doc: page: curent page index")
		util.Printlnf("  misoapi-header-doc: Authorization: bearer authorization token")
		util.Printlnf("  misoapi-scope: PROTECTED")
		util.Printlnf("  misoapi-resource: document:read")
		util.Printlnf("")
	}
	flag.Parse()

	files, err := walkDir(".")
	if err != nil {
		util.Printlnf("error - %v", err)
		return
	}
	if err := parseFiles(files); err != nil {
		util.Printlnf("error - %v", err)
	}
}

type GroupedApiDecl struct {
	Dir  string
	Pkg  string
	Apis []ApiDecl
}

type FsFile struct {
	Path string
	File fs.FileInfo
}

func parseFiles(files []FsFile) error {
	dstFiles, err := parseFileAst(files)
	if err != nil {
		return err
	}

	if *Debug {
		for _, f := range dstFiles {
			util.Printlnf("Found %v", f.Path)
		}
	}

	pathApiDecls := make(map[string]GroupedApiDecl)
	addApiDecl := func(p string, pkg string, d ApiDecl) {
		dir, _ := path.Split(p)
		v, ok := pathApiDecls[dir]
		if ok {
			v.Apis = append(v.Apis, d)
			pathApiDecls[dir] = v
		} else {
			pathApiDecls[dir] = GroupedApiDecl{
				Dir:  dir,
				Pkg:  pkg,
				Apis: []ApiDecl{d},
			}
		}
	}
	for _, df := range dstFiles {
		dstutil.Apply(df.Dst,
			func(c *dstutil.Cursor) bool {
				ad, ok := parseApiDecl(c, df.Path)
				if ok {
					addApiDecl(df.Path, df.Dst.Name.Name, ad)
				}
				return true
			},
			func(cursor *dstutil.Cursor) bool {
				return true
			},
		)
	}

	baseIndent := 1
	for dir, v := range pathApiDecls {
		for _, ad := range v.Apis {
			if *Debug {
				util.Printlnf("%v (%v) => %#v", dir, v.Pkg, ad)
			}
		}
		imports, code, err := genGoApiRegister(v.Apis, baseIndent)
		if err != nil {
			util.Printlnf("error - %v", err)
			continue
		}

		importSb := strings.Builder{}
		for s := range imports.Keys {
			if importSb.Len() > 0 {
				importSb.WriteString("\n")
			}
			importSb.WriteString(strings.Repeat("\t", baseIndent) + "\"" + s + "\"")
		}

		out := util.NamedSprintf(`// auto generated by misoapi ${misoVersion} at ${nowTimeStr}
// please do not modify
package ${package}

import (
${importStr}
)

func init() {
${code}
}
`, map[string]any{
			"misoVersion": version.Version,
			"nowTimeStr":  util.Now().FormatClassic(),
			"package":     v.Pkg,
			"code":        code,
			"importStr":   importSb.String(),
		})

		if *Debug {
			util.Printlnf("%v (%v) => \n\n%v", dir, v.Pkg, out)
		}
		outFile := fmt.Sprintf("%vmisoapi_generated.go", dir)
		util.Printlnf("Generated code written to %v, using pkg: %v, api count: %d", outFile, v.Pkg, len(v.Apis))

		f, err := util.ReadWriteFile(outFile)
		if err != nil {
			panic(err)
		}
		err = f.Truncate(0)
		if err != nil {
			panic(err)
		}
		_, err = f.WriteString(out)
		if err != nil {
			panic(err)
		}
		f.Close()
	}

	return nil
}

type DstFile struct {
	Dst  *dst.File
	Path string
}

func parseApiDecl(cursor *dstutil.Cursor, path string) (ApiDecl, bool) {
	switch n := cursor.Node().(type) {
	case *dst.FuncDecl:
		tags, ok := parseMisoApiTag(path, n.Decs.Start)
		if ok {
			if *Debug {
				util.Printlnf("type results: %#v", n.Type.Results)
				util.Printlnf("tags: %+v", tags)
			}
			for _, t := range tags {
				kv, ok := t.BodyKV()
				if *Debug {
					util.Printlnf("tag -> %#v, kv: %#v, ok: %v", t, kv, ok)
				}
			}
			ad, ok := BuildApiDecl(tags)
			if ok {
				ad.FuncParams = parseParamMeta(n.Type.Params)
				ad.FuncResults = parseParamMeta(n.Type.Results)
				ad.FuncName = n.Name.String()
			}
			return ad, ok
		}
	}
	return ApiDecl{}, false
}

func parseParamMeta(l *dst.FieldList) []ParamMeta {
	if l == nil {
		return []ParamMeta{}
	}
	pm := make([]ParamMeta, 0)
	for i, p := range l.List {
		var varName string
		if len(p.Names) > 0 {
			varName = p.Names[0].String()
		}

		var typeName string
		switch v := p.Type.(type) {
		case *dst.SelectorExpr:
			typeName = v.X.(*dst.Ident).Name
			sn := v.Sel.String()
			if sn != "" {
				typeName = typeName + "." + sn
			}
		case *dst.Ident:
			typeName = v.Name
		case *dst.StarExpr:
			xsel := v.X.(*dst.SelectorExpr)
			typeName = xsel.X.(*dst.Ident).Name
			sn := xsel.Sel.String()
			if sn != "" {
				typeName = typeName + "." + sn
			}
		case *dst.ArrayType:
			typeName = "[]" + v.Elt.(*dst.Ident).Name
		default:
			util.Printlnf("error - failed to parse param[%d]: %v %#v", i, p.Names, p.Type)
		}
		if typeName != "" {
			pm = append(pm, ParamMeta{Name: varName, Type: typeName})
		}
	}
	return pm
}

type ParamMeta struct {
	Name string
	Type string
}

type ApiDecl struct {
	Method   string
	Url      string
	Header   []Pair
	Query    []Pair
	Desc     string
	Scope    string
	Resource string

	FuncName    string
	FuncParams  []ParamMeta
	FuncResults []ParamMeta
}

func genGoApiRegister(dec []ApiDecl, baseIndent int) (util.Set[string], string, error) {
	w := util.NewIndentWriter("\t")
	w.SetIndent(baseIndent)
	imports := util.NewSet[string]()
	imports.Add(importMiso)

	for i, d := range dec {
		var custReqType string

		for _, p := range d.FuncParams {
			switch p.Type {
			case typeMisoInbound, typeMisoRail, typeGormDb:
				continue
			case typeCommonUser:
				imports.Add(importCommonUser)
				continue
			default:
				if custReqType == "" {
					custReqType = p.Type
				}
			}
		}

		var custResType string
		for _, p := range d.FuncResults {
			switch p.Type {
			case "error":
				continue
			case typeCommonUser:
				if custResType == "" {
					custResType = p.Type
				}
				imports.Add(importCommonUser)
				continue
			default:
				if custResType == "" {
					custResType = p.Type
				}
			}
		}

		resType := "any"
		if custResType != "" {
			resType = custResType
		}

		mtd := d.Method[:1] + strings.ToLower(d.Method[1:])
		if custReqType != "" {
			w.Writef("miso.I%v(\"%v\",", mtd, d.Url)
			w.IncrIndent()
			w.Writef("func(inb *miso.Inbound, req %v) (%v, error) {", custReqType, resType)
			w.StepIn(func(w *util.IndentWriter) {
				paramTokens := make([]string, 0, len(d.FuncParams))
				for _, p := range d.FuncParams {
					var v string
					switch p.Type {
					case typeMisoInbound:
						v = "inb"
					case typeMisoRail:
						v = "inb.Rail()"
					case typeGormDb:
						v = "miso.GetMySQL()"
					case typeCommonUser:
						v = "common.GetUser(inb.Rail())"
					case custReqType:
						v = "req"
					}
					paramTokens = append(paramTokens, v)
				}
				w.Writef("return %v(%v)", d.FuncName, strings.Join(paramTokens, ", "))
			})
			w.NoLbWritef("})")
		} else {
			isRaw := len(d.FuncParams) == 1 && d.FuncParams[0].Type == typeMisoInbound && len(d.FuncResults) < 1
			if isRaw {
				w.NoLbWritef("miso.Raw%v(\"%v\", %v)", mtd, d.Url, d.FuncName)
				if d.Desc != "" || len(d.Header) > 0 || len(d.Query) > 0 {
					w.IncrIndent()
				}
			} else {
				w.Writef("miso.%v(\"%v\",", mtd, d.Url)
				w.IncrIndent()
				w.Writef("func(inb *miso.Inbound) (%v, error) {", resType)
				w.StepIn(func(w *util.IndentWriter) {
					paramTokens := make([]string, 0, len(d.FuncParams))
					for _, p := range d.FuncParams {
						var v string
						switch p.Type {
						case typeMisoInbound:
							v = "inb"
						case typeMisoRail:
							v = "inb.Rail()"
						case typeGormDb:
							v = "miso.GetMySQL()"
						case typeCommonUser:
							v = "common.GetUser(inb.Rail())"
						}
						paramTokens = append(paramTokens, v)
					}
					w.Writef("return %v(%v)", d.FuncName, strings.Join(paramTokens, ", "))
				})
				w.NoLbWritef("})")
			}
		}
		if d.Desc != "" {
			w.NoIndWritef(".\n")
			if d.Scope != "" || d.Resource != "" || len(d.Header) > 0 || len(d.Query) > 0 {
				w.NoLbWritef("Desc(\"%v\")", d.Desc)
			} else {
				w.Writef("Desc(\"%v\")", d.Desc)
			}
		}
		if d.Scope != "" {
			w.NoIndWritef(".\n")
			var l string
			switch d.Scope {
			case "PROTECTED":
				l = "Protected()"
			case "PUBLIC":
				l = "Public()"
			default:
				l = fmt.Sprintf("Scope(\"%v\")", d.Scope)
			}
			if d.Resource != "" || len(d.Header) > 0 || len(d.Query) > 0 {
				w.NoLbWritef(l)
			} else {
				w.Writef(l)
			}
		}
		if d.Resource != "" {
			w.NoIndWritef(".\n")
			if len(d.Header) > 0 || len(d.Query) > 0 {
				w.NoLbWritef("Resource(\"%v\")", d.Resource)
			} else {
				w.Writef("Resource(\"%v\")", d.Resource)
			}
		}
		for i, dh := range d.Header {
			w.NoIndWritef(".\n")
			if i < len(d.Header)-1 || len(d.Query) > 0 {
				w.NoLbWritef("DocHeader(\"%v\", \"%v\")", dh.K, dh.V)
			} else {
				w.Writef("DocHeader(\"%v\", \"%v\")", dh.K, dh.V)
			}
		}
		for i, dh := range d.Query {
			w.NoIndWritef(".\n")
			if i < len(d.Query)-1 {
				w.NoLbWritef("DocQueryParam(\"%v\", \"%v\")", dh.K, dh.V)
			} else {
				w.Writef("DocQueryParam(\"%v\", \"%v\")", dh.K, dh.V)
			}
		}
		if i < len(dec)-1 {
			w.NoIndWritef("\n")
		}
		w.SetIndent(baseIndent)
	}
	return imports, w.String(), nil
}

func BuildApiDecl(tags []MisoApiTag) (ApiDecl, bool) {
	ad := ApiDecl{}
	for _, t := range tags {
		switch t.Command {
		case tagHttp:
			lr := strings.SplitN(t.Body, " ", 2)
			if len(lr) < 2 {
				return ad, false
			}
			ad.Method = strings.ToUpper(strings.TrimSpace(lr[0]))
			ad.Url = strings.TrimSpace(lr[1])
		case tagDesc:
			ad.Desc = t.Body
		case tagScope:
			ad.Scope = t.Body
		case tagRes:
			ad.Resource = t.Body
		case tagQueryDoc:
			kv, ok := t.BodyKV()
			if ok {
				ad.Query = append(ad.Query, kv)
			}
		case tagHeaderDoc:
			kv, ok := t.BodyKV()
			if ok {
				ad.Header = append(ad.Header, kv)
			}
		}
	}
	return ad, !util.IsBlankStr(ad.Method) && !util.IsBlankStr(ad.Url)
}

type Pair struct {
	K string
	V string
}

type MisoApiTag struct {
	Command string
	Body    string
}

func (m *MisoApiTag) BodyKV() (Pair, bool) {
	i := strings.Index(m.Body, ":")
	if i < 0 {
		return Pair{}, false
	}
	return Pair{
		K: strings.TrimSpace(m.Body[:i]),
		V: strings.TrimSpace(m.Body[i+1:]),
	}, true
}

func parseMisoApiTag(path string, start dst.Decorations) ([]MisoApiTag, bool) {
	t := []MisoApiTag{}
	for _, s := range start {
		s, _ = strings.CutPrefix(s, "//")
		s = strings.TrimSpace(s)
		if m, ok := strings.CutPrefix(s, MisoApiPrefix); ok {
			if pi := strings.Index(m, ":"); pi > -1 {
				pre := m[:pi]
				m = m[pi+1:]
				if *Debug {
					util.Printlnf("%v -> %v, command: %v, body: %v", path, s, pre, m)
				}
				// return OutputFile{}, false
				t = append(t, MisoApiTag{
					Command: strings.TrimSpace(pre),
					Body:    strings.TrimSpace(m),
				})
			} else {
				continue
			}
		}
	}
	return t, len(t) > 0
}

func parseFileAst(files []FsFile) ([]DstFile, error) {
	parsed := make([]DstFile, 0)
	for _, f := range files {
		p := f.Path
		if path.Base(p) == "misoapi_generated.go" {
			continue
		}
		d, err := decorator.ParseFile(nil, p, nil, parser.ParseComments)
		if err != nil {
			return nil, err
		}
		parsed = append(parsed, DstFile{
			Dst:  d,
			Path: p,
		})
	}
	return parsed, nil
}

func walkDir(n string) ([]FsFile, error) {
	entries, err := os.ReadDir(n)
	if err != nil {
		return nil, err
	}
	files := make([]FsFile, 0, len(entries))
	for _, et := range entries {
		fi, err := et.Info()
		if err != nil {
			util.Printlnf("error - %v", err)
			continue
		}
		p := n + "/" + fi.Name()
		if et.IsDir() {
			ff, err := walkDir(p)
			if err == nil {
				files = append(files, ff...)
			}
		} else {
			if strings.HasSuffix(fi.Name(), ".go") {
				files = append(files, FsFile{File: fi, Path: p})
			}
		}
	}
	return files, nil
}
